"""
Takes an array of bytes and encodes it into a chunked barcode

padding data padding data ...
"""

from itertools import chain

#========================================================
# Given an encoding scheme (units in space length)
# generates a table mapping integers to encodings
#
# padding: an array describing the padding eg [2,1,1,1,2]
# dataLen: Length of the data itself
# p: multiplicative factor in shuffling, should be relatively prime to numCodes
# q: additive factor in shuffling
# numCodes: Total number of codes
# maxDataNotches: Maximum number of notches in the padding+data
# minDataNotches: Minimum number of notches in the padding+data
# allowPalindromes: if False, removes palindromes and flipped equivalents
#========================================================
def generateLookupTable(padding, dataLen, p, q,
    numCodes=256, maxDataNotches=-1, minDataNotches = 0, allowPalindromes=False):

    length = 1 + 2 * sum(padding) + dataLen
    maxNotches = 2 * len(padding) + maxDataNotches
    minNotches = 2 * len(padding) + minDataNotches

    def isPalindrome(code):
        return code == code[::-1]

    def containsPadding(code):
        return code[len(code)-len(padding):] == padding

    def generateCode(code):
        if maxNotches > 0 and len(code) > maxNotches - len(padding):
            return []
        if sum(code) > length - sum(padding):
            return []
        if len(code) > len(padding) and containsPadding(code):
            return []
        if sum(code) == length - sum(padding) and (allowPalindromes or not isPalindrome(code[len(padding):])):
            return addEndPadding(code)
        return generateCode(code + [2]) + generateCode(code + [1])

    def addEndPadding(code):
        if len(code) < minNotches - len(padding):
            return []
        for space in padding:
            if containsPadding(code):
                return []
            code += [space]
        return [code]

    table = generateCode(padding)

    def gcd(a, b):
        while b != 0:
            t = a
            a = b
            b = t % b
        return a

    if gcd(len(table), p) != 1:
        raise ValueError('p is not relatively prime to length of possible codes: ' + str(len(table)))

    # remove padding
    table = [code[len(padding):-len(padding)] for code in table]

    table = shuffle_table(table, p, q)
    if not allowPalindromes:
        table = remove_flipped_codes(table)

    if len(table) < numCodes:
        raise ValueError('Not enough available codes: '+str(len(table)))

    table = table[0:numCodes]

    return table

#========================================================
# data: array of bytes
# table: lookup table generated by generateLookupTable
# padding: same padding used to generate lookup table
#========================================================
def encodeToSpacing(data, table, padding):

    data = [table[n] for n in data]

    data = [x for code in data for x in [code, padding]]

    data = [padding] + data

    return list(chain(*data))

def spacesToString(code):
    def spaceToString(b):
        if b == 2:
            return ' |'
        else:
            return '|'
    return '|' + ''.join(map(spaceToString, code))

def shuffle_table(table, p, q):
    # these magic numbers obviously have significant
    # p = 18491 # 11 * 41 * 41
    # q = 18551 # 13 * 1427
    size = len(table)

    def shuffle_index(i):
        return ((i + q) * p) % size

    return [table[shuffle_index(i)] for i in xrange(0, size)]

# remove codes that come after its flipped version
def remove_flipped_codes(table):
    noFlipTable = []
    seen = set()
    for code in table:
        if spacesToBinary(code[::-1]) not in seen:
            seen.add(spacesToBinary(code))
            noFlipTable.append(code)

    return noFlipTable

# the binary number corresponds to the notches
def spacesToBinary(code):
    n = 1
    for space in code:
        n <<= 1
        if space == 2:
            n <<= 1
            n |= 1
        else:
            n |= 1
    return n

# the notches correspond to the binary number
def binaryToSpaces(n):
    code = []
    while n > 1:
        n >>= 1
        notch = n & 1
        if notch > 0:
            code.append(1)
        else:
            code.append(2)
            n >>= 1
    return code[::-1]

# padding = [2,1,1,1,2]
# table = generateLookupTable(padding, 14, 18491, 18551, maxDataNotches=13, minDataNotches=10)

# for code in table:
#     print '|'+''.join(map(lambda x: '|' if x == 1 else ' |', code))

# for code in encodeToSpacing([0, 1, 2], table, padding):
# barcode =  '|'+''.join(map(lambda x: '|' if x == 1 else ' |', encodeToSpacing([0, 1, 2], table, padding)))
# print barcode
# print barcode.replace('| |||| |', '|\n|')

# for code in table[0:3]:
#     print '|'+''.join(map(lambda x: '|' if x == 1 else ' |', code))
